1. 接口是系统可拔插性保证！
2. 接口和抽象类的选择：
	1.优先选择接口
	2.在既要定义子类行为，又要为子类提供公共的功能时应选择抽象类！
3. 何时使用简单工厂：（因为在真实的项目中，客户根本不知道具体的实现类是Impl，例如下面代码中的
	24行，但是我们在使用接口的实现类，也就是我们只知道接口，但是不知道该由谁实现
	这时我们考虑使用简单工厂模式来创建）
	public interface Api {
		void test1(String s);
	}
	
	public class Impl implements Api{
		@Override
		public void test1(String s) {
			// TODO Auto-generated method stub
			
			System.out.println("Now In Impl. The input s==" + s);
		}
	}
	
	public class Client {

		public static void main(String[] args){
			Api api = new Impl();
			api.test1("哈哈，不要紧张，只是个测试而已");
		}
	}
3. 简单工厂：提供一个创建对象实例的功能，而无须关心接口的实现，被创建的实例类型可以是接口，抽象类，也可以
是具体的类

类比到生活中的商品，我们只需要知道商品的制造商，而不需要商品的制造流程
4. 事实上，简单工厂能帮助我们真正地开始面向接口编程，像以前的做法，只是用到了接口的多态部分的功能
而最重要的"封装隔离性"没有体现出来
5.把new Impl() 与 放到简单工厂里面有什么不同么？
	接口是用来封装隔离具体实现的，目标就是不让客户端知道封装体内部的具体实现，简单工厂的位置是位于封装
体内的，也就是简单工厂是跟接口和具体的实现在一起的，算是封装体内部的一个类，所以简单工厂知道具体的实现类
是没什么关系的。
6.简单工厂的功能：
	在JAVA里面，通常情况下是用来创造接口的，但是也可以创造抽象类，甚至是一个具体的类实例
7. 静态工厂，使用简单工厂的时候，我们没有创建实例的必要，直接使用静态方法就可以了，也就是说简单工厂的方法
通常是静态的，也叫静态工厂，如果要防止客户端无谓的创造简单工厂实例，还可以把简单工厂的构造方法私有化
8. 万能工厂，一个简单工厂可以包含很多用来构造东西的方法，这些方法可以创建不同的接口，抽象类或者是
类实例。一个简单工厂理论上可以构造任何东西，因此被称之为万能工厂
9. 简单工厂创建对象的范围：
	虽然简单工厂什么都可以串改就能，但对于简单工厂可以创建的范围，通常不要太大，建议控制在一个独立的组件
级别或者一个模块级别，也就是一个组件或者一个模块简单工厂，否则这个简单工厂类会职责不明，有点大杂烩的感觉
10.简单工厂的调用顺序示意图
	1.调用简单工厂中创建的API方法，
	2.真正选择并创建具体实现对象的实例
	3.返回创建好的接口对象
	4.调用接口的方法进行功能处理
11.简单工厂命名建议：
	1.类名建议命名为 "模块名称 + Factory"，比如用户模块的工厂为 UserFactory
	2.方法名通常为 "get + 接口名称" 或者 "create + 接口名称"， 例如，接口名称为 UserEbi ,方法名称为
	getUserEbi 或者 createUserEbi
12.简单工厂方法的内部主要功能是选择合适的实现类来创建实例对象，那么既然选择，肯定需要选择条件或者选择参数
选择条件或者选择参数来源有以下几种：
	1.来源于客户端，由Client来传入参数（每次有了新的实现类，都必须在工厂类中再增加条件来进行判断，比较
	繁琐）
		使用这种方法有一定的缺点，由于客户端使用该方法的时候必须传入参数，因此客户必须知道每个参数的意义
	这也就在一定程度上向客户暴露了内部实现的细节
	2.来源于配置文件，从配置文件获取用于判断的值（每次增加了新的实现类，不需要修改工厂类，只需要在配置
	文件中增加新的实现类就可以，在简单的工厂模式里面，我们可以使用反射，也可以使用IoC/DI(控制反转/依赖
	注入)）
	3.来源于程序运行期的某个值，比如从缓存中获取某个运行期的值
13.简单工厂模式的优缺点：
优点:	1.帮助封装：简单工厂虽然很简单，但是非常友好的帮助我们实现了组件的封装，然后让组件外部能真正
面向接口编程
		2.解耦：通过简单工厂，实现了客户端和具体实现类的解耦
		因为客户端根本不知道具体是由谁来实现的，也不知道具体是如何实现的，客户端只是通过工厂获取它需要的
接口对象
缺点：	1.可能增加客户端的复杂度
		如果通过客户端的参数选择具体的实现类，那么就必须让客户端能理解各个参数所代表的具体功能和含义，
这样会增加客户端的使用难度，也部分暴露了内部实现，这种情况可以使用可配置的方式来实现
		2.不方便扩展子工厂
		私有化简单工厂的构造方法，使用静态方法来创建接口，也就不能通过写简单的工厂类的子类来改变创建接口
的方法的行为了。不过，通常情况下是不需要为简单工厂创建子类的。
14.简单工厂的本质：选择实现
	注意简单工厂的重点在实现，实现是已经做好了的，就算实现再简单，也要由具体的实现类来实现，而不是在简单
工厂里面来实现，简单工厂的目的是在于为客户端来选择相应的实现，从而使得客户端和实现之间解耦，这样一来，具体
类发生改变，不再需要修改客户端了，这个变化就会被简单工厂吸收和屏蔽掉！
	其实实现简单工厂难点在于“如何选择”实现，前面讲到了几种传递参数的方法，都是静态参数，但是可以变为动态
参数，比如，在运行期间，由工厂去读取某个内存的值，或者是去读取数据库中的值，然后根据这个值来选择具体的实现
15.何时选用简单工厂模式：
	1.如果想要完全封装隔离具体实现，让外部只能通过接口来操作封装体，那么可以选用简单工厂，让客户端通过工
厂来获取相应的接口，而无须关心具体的实现。
	2.如果想要把对外创建对象的职责几种管理和控制，可以选用简单工厂，一个简单工厂可以创建很多的，不相关的
对象，可以把对外创建对象的职责集中到一个简单工厂来，从而实现几种管理和控制
16.简单工厂模式，抽象工厂模式 与 工厂方法模式
	简单工厂是用来选择实现的，可以选择任意接口的实现，一个简单工厂可以有多个用于选择并创建对象的方法，多个
方法创建的对象可以有关系也可以没有关系。
	抽象工厂模式是用来选择产品簇的实现的，也就是说一般抽象工厂里面有多个用于选择并创建对象的方法，但是这些
方法所创建的对象之间通常有关系，这些被创建的对象通常是构成一个产品簇所需要的部件对象！
	简单工厂与抽象工厂模式是类似的，如果抽象工厂退化成为只有一个实现，不分层次，那么就相当于简单工厂
	
	简单工厂和工厂方法模式
	工厂方法的本质是用来选择实现的，跟简单工厂的区别在于工厂方法是把选择具体实现的功能延迟到子类去实现。
如果把工厂方法中选择的实现放到父类直接实现，那就等同于简单工厂
	